import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
import { mkdirSync, writeFileSync, readFileSync, rmSync, existsSync } from "fs";
import { join } from "path";
import { uninstall } from "../../src/commands/uninstall.js";

// Mock clack to keep output quiet and handle interactive mode
vi.mock("@clack/prompts", () => ({
  intro: vi.fn(),
  outro: vi.fn(),
  cancel: vi.fn(),
  log: {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    success: vi.fn(),
  },
  select: vi.fn().mockResolvedValue("convert"),
  confirm: vi.fn().mockResolvedValue(true),
  isCancel: vi.fn().mockReturnValue(false),
  spinner: vi.fn(() => ({
    start: vi.fn(),
    stop: vi.fn(),
    message: vi.fn(),
  })),
}));

describe("uninstall command", () => {
  let tempDir: string;
  let originalCwd: string;
  let _exitSpy: ReturnType<typeof vi.spyOn>;
  let logSpy: ReturnType<typeof vi.spyOn>;
  let _errorSpy: ReturnType<typeof vi.spyOn>;

  beforeEach(() => {
    tempDir = join(process.cwd(), `.uninstall-test-${Date.now()}`);
    mkdirSync(tempDir, { recursive: true });
    originalCwd = process.cwd();
    process.chdir(tempDir);

    logSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    _errorSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    vi.spyOn(console, "warn").mockImplementation(() => {});
    _exitSpy = vi.spyOn(process, "exit").mockImplementation(((
      code?: number,
    ) => {
      throw new Error(`process.exit: ${code}`);
    }) as never);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    vi.restoreAllMocks();
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true });
    }
  });

  /**
   * Create a basic AlignTrue installation
   */
  function setupAlignTrue(): void {
    // Create .aligntrue directory
    mkdirSync(".aligntrue/rules", { recursive: true });
    mkdirSync(".aligntrue/.backups", { recursive: true });

    // Create config
    writeFileSync(
      ".aligntrue/config.yaml",
      [
        "mode: solo",
        "sources:",
        "  - type: local",
        "    path: .aligntrue/rules",
        "exporters:",
        "  - cursor",
        "  - agents",
      ].join("\n"),
      "utf-8",
    );

    // Create source rule
    writeFileSync(
      ".aligntrue/rules/typescript.md",
      "---\ntitle: TypeScript\n---\n\n# TypeScript\n\nUse strict mode.\n",
      "utf-8",
    );

    // Create exports with READ-ONLY markers
    mkdirSync(".cursor/rules", { recursive: true });
    writeFileSync(
      ".cursor/rules/typescript.mdc",
      `<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

---
description: TypeScript
globs: "**/*.ts"
---

# TypeScript

Use strict mode.
`,
      "utf-8",
    );

    writeFileSync(
      "AGENTS.md",
      `<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Agent Rules

## TypeScript

Use strict mode.
`,
      "utf-8",
    );

    // Create .gitignore with AlignTrue entries
    writeFileSync(
      ".gitignore",
      `node_modules/
dist/

# START AlignTrue Generated Files
.aligntrue/.backups/
.cursor/rules/*.mdc
AGENTS.md
# END AlignTrue Generated Files
`,
      "utf-8",
    );
  }

  describe("--help", () => {
    it("shows help text", async () => {
      await expect(uninstall(["--help"])).rejects.toThrow("process.exit: 0");

      const output = logSpy.mock.calls.map((call) => call[0]).join("\n");
      expect(output).toContain("aligntrue uninstall");
      expect(output).toContain("--dry-run");
      expect(output).toContain("--non-interactive");
    });
  });

  describe("when AlignTrue is not installed", () => {
    it("exits gracefully", async () => {
      await expect(uninstall(["-y"])).rejects.toThrow("process.exit: 0");

      const output = logSpy.mock.calls.map((call) => call[0]).join("\n");
      expect(output).toContain("not installed");
    });
  });

  describe("--dry-run", () => {
    it("shows preview without making changes", async () => {
      setupAlignTrue();

      await expect(
        uninstall(["--dry-run", "-y", "--convert-exports"]),
      ).rejects.toThrow("process.exit: 0");

      // Files should still exist
      expect(existsSync(".aligntrue/config.yaml")).toBe(true);
      expect(existsSync(".cursor/rules/typescript.mdc")).toBe(true);
      expect(existsSync("AGENTS.md")).toBe(true);

      const output = logSpy.mock.calls.map((call) => call[0]).join("\n");
      expect(output).toContain("Dry run");
      expect(output).toContain("No changes made");
    });
  });

  describe("--convert-exports", () => {
    it("removes READ-ONLY markers from exported files", async () => {
      setupAlignTrue();

      await uninstall(["-y", "--convert-exports", "--keep-source"]);

      // Source should be kept
      expect(existsSync(".aligntrue/config.yaml")).toBe(true);
      expect(existsSync(".aligntrue/rules/typescript.md")).toBe(true);

      // Exports should still exist but without READ-ONLY markers
      expect(existsSync(".cursor/rules/typescript.mdc")).toBe(true);
      expect(existsSync("AGENTS.md")).toBe(true);

      const cursorContent = readFileSync(
        ".cursor/rules/typescript.mdc",
        "utf-8",
      );
      expect(cursorContent).not.toContain("READ-ONLY");
      expect(cursorContent).toContain("# TypeScript");

      const agentsContent = readFileSync("AGENTS.md", "utf-8");
      expect(agentsContent).not.toContain("READ-ONLY");
      expect(agentsContent).toContain("# Agent Rules");
    });
  });

  describe("--delete-exports", () => {
    it("deletes all exported files", async () => {
      setupAlignTrue();

      await uninstall(["-y", "--delete-exports", "--keep-source"]);

      // Source should be kept
      expect(existsSync(".aligntrue/config.yaml")).toBe(true);
      expect(existsSync(".aligntrue/rules/typescript.md")).toBe(true);

      // Exports should be deleted
      expect(existsSync(".cursor/rules/typescript.mdc")).toBe(false);
      expect(existsSync("AGENTS.md")).toBe(false);
    });
  });

  describe("--delete-source", () => {
    it("deletes .aligntrue directory", async () => {
      setupAlignTrue();

      await uninstall(["-y", "--keep-exports", "--delete-source"]);

      // Source should be deleted
      expect(existsSync(".aligntrue")).toBe(false);

      // Exports should be kept (with markers)
      expect(existsSync(".cursor/rules/typescript.mdc")).toBe(true);
      expect(existsSync("AGENTS.md")).toBe(true);

      const cursorContent = readFileSync(
        ".cursor/rules/typescript.mdc",
        "utf-8",
      );
      expect(cursorContent).toContain("READ-ONLY");
    });
  });

  describe("full uninstall", () => {
    it("removes everything when --delete-exports and --delete-source are used", async () => {
      setupAlignTrue();

      await uninstall(["-y", "--delete-exports", "--delete-source"]);

      // Everything should be deleted
      expect(existsSync(".aligntrue")).toBe(false);
      expect(existsSync(".cursor/rules/typescript.mdc")).toBe(false);
      expect(existsSync("AGENTS.md")).toBe(false);
    });
  });

  describe("gitignore cleanup", () => {
    it("removes AlignTrue entries from .gitignore", async () => {
      setupAlignTrue();

      await uninstall(["-y", "--convert-exports", "--keep-source"]);

      // .gitignore should still exist but without AlignTrue entries
      expect(existsSync(".gitignore")).toBe(true);

      const gitignoreContent = readFileSync(".gitignore", "utf-8");
      expect(gitignoreContent).toContain("node_modules/");
      expect(gitignoreContent).not.toContain("START AlignTrue");
      expect(gitignoreContent).not.toContain("END AlignTrue");
    });
  });

  describe("backup creation", () => {
    it("creates a backup before making changes", async () => {
      setupAlignTrue();

      await uninstall(["-y", "--convert-exports", "--keep-source"]);

      // Backup should have been created
      expect(existsSync(".aligntrue/.backups")).toBe(true);

      const output = logSpy.mock.calls.map((call) => call[0]).join("\n");
      expect(output).toContain("Backup created");
    });
  });

  describe("lockfile handling", () => {
    it("deletes lockfile when present", async () => {
      setupAlignTrue();

      // Create lockfile
      writeFileSync(
        ".aligntrue/lock.json",
        JSON.stringify({ version: "1.0", rules: [] }),
        "utf-8",
      );

      expect(existsSync(".aligntrue/lock.json")).toBe(true);

      await uninstall(["-y", "--keep-exports", "--keep-source"]);

      // Lockfile should be deleted
      expect(existsSync(".aligntrue/lock.json")).toBe(false);
    });
  });
});
