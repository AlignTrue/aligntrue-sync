/**
 * Section parser utility for agent files
 * Parses existing agent files and extracts sections with metadata for merging
 */

import { createHash } from "crypto";

export interface ParsedSection {
  id: string; // Section heading as identifier
  hash: string; // Content hash for change detection
  heading: string; // Full heading text
  content: string; // Section body content
  level: number; // Heading level (1-6)
  startLine: number; // For debugging/diff
  endLine: number; // For debugging/diff
  isTeamManaged?: boolean; // Detected from markers
}

export interface ParsedFile {
  sections: ParsedSection[];
  header: string; // File header before first section
  footer: string; // File footer with hash/metadata
  contentHash: string | undefined; // Extracted from footer
}

/**
 * Parse AGENTS.md format
 * Extracts sections, header, footer, and content hash
 */
export function parseAgentsMd(content: string): ParsedFile {
  return parseMarkdownSections(content, {
    hasYamlFrontmatter: false,
    footerStart: "---",
  });
}

/**
 * Parse Cursor .mdc format
 * Handles YAML frontmatter and extracts sections
 */
export function parseCursorMdc(content: string): ParsedFile {
  return parseMarkdownSections(content, {
    hasYamlFrontmatter: true,
    footerStart: "---",
  });
}

/**
 * Parse generic markdown (CLAUDE.md, GEMINI.md, etc.)
 */
export function parseGenericMarkdown(content: string): ParsedFile {
  return parseMarkdownSections(content, {
    hasYamlFrontmatter: false,
    footerStart: "---",
  });
}

interface ParseOptions {
  hasYamlFrontmatter: boolean;
  footerStart: string;
}

/**
 * Core markdown section parser
 * Handles different markdown formats with configurable options
 */
function parseMarkdownSections(
  content: string,
  options: ParseOptions,
): ParsedFile {
  const lines = content.split("\n");
  const sections: ParsedSection[] = [];
  let header = "";
  let footer = "";
  let contentHash: string | undefined;

  let currentSection: Partial<ParsedSection> | null = null;
  let currentContent: string[] = [];
  let lineIndex = 0;
  let headerEndLine = 0;

  // Parse header (YAML frontmatter or file header before first section)
  if (options.hasYamlFrontmatter && lines[0]?.trim() === "---") {
    // Parse YAML frontmatter
    const headerLines: string[] = ["---"];
    lineIndex = 1;

    while (lineIndex < lines.length && lines[lineIndex]?.trim() !== "---") {
      headerLines.push(lines[lineIndex] || "");
      lineIndex++;
    }

    if (lineIndex < lines.length) {
      headerLines.push("---");
      lineIndex++;
    }

    header = headerLines.join("\n");
    headerEndLine = lineIndex;
  }

  // Skip file title heading if it looks like a file title
  // (e.g., "# AGENTS.md", "# CLAUDE.md", etc.)
  if (lineIndex < lines.length) {
    const firstLine = lines[lineIndex]?.trim() || "";
    if (
      firstLine.match(/^#\s+[A-Z][A-Z_-]*\.md$/i) ||
      firstLine.match(/^#\s+AGENTS\.md$/i)
    ) {
      // This looks like a file title, skip it
      lineIndex++;
    }
  }

  // Pre-process: find all lines within team-managed HTML comments
  const teamManagedLines = new Set<number>();
  let inTeamManagedComment = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i] || "";

    // Check for comment start with [TEAM-MANAGED]
    if (line.includes("<!--") && line.includes("[TEAM-MANAGED]")) {
      inTeamManagedComment = true;
      teamManagedLines.add(i);
      // Check if it closes on same line
      if (line.includes("-->")) {
        inTeamManagedComment = false;
      }
    } else if (inTeamManagedComment) {
      teamManagedLines.add(i);
      // Check for comment end
      if (line.includes("-->")) {
        inTeamManagedComment = false;
      }
    }
  }

  // Parse sections and content
  let inFooter = false;
  const footerLines: string[] = [];

  for (; lineIndex < lines.length; lineIndex++) {
    const line = lines[lineIndex] || "";

    // Check for footer start
    if (
      !inFooter &&
      line.trim() === options.footerStart &&
      lineIndex > headerEndLine
    ) {
      // Check if this looks like a footer (contains "Generated by AlignTrue" or "Content Hash")
      const remainingContent = lines.slice(lineIndex).join("\n");
      if (
        remainingContent.includes("Generated by AlignTrue") ||
        remainingContent.includes("Content Hash:")
      ) {
        inFooter = true;

        // Save current section if exists
        if (currentSection) {
          currentSection.content = currentContent.join("\n").trim();
          currentSection.endLine = lineIndex - 1;
          sections.push(currentSection as ParsedSection);
          currentSection = null;
          currentContent = [];
        }

        footerLines.push(line);
        continue;
      }
    }

    if (inFooter) {
      footerLines.push(line);
      continue;
    }

    // Check for heading
    const headingMatch = line.match(/^(#{1,6})\s+(.+?)$/);

    if (headingMatch) {
      // Save previous section
      if (currentSection) {
        currentSection.content = currentContent.join("\n").trim();
        currentSection.endLine = lineIndex - 1;
        sections.push(currentSection as ParsedSection);
      }

      // Check if this heading immediately follows a team-managed comment
      // Look back from this heading until we hit the previous heading (or start of file)
      let isTeamManaged = false;

      // Find where the previous section starts
      let prevHeadingLine = -1;
      for (let i = lineIndex - 1; i >= 0; i--) {
        const checkLine = (lines[i] || "").trim();
        if (checkLine.match(/^#{1,6}\s+/)) {
          prevHeadingLine = i;
          break;
        }
      }

      // Look for team-managed marker between previous heading and this heading
      const searchStart = prevHeadingLine + 1;
      for (let i = searchStart; i < lineIndex; i++) {
        if (teamManagedLines.has(i)) {
          isTeamManaged = true;
          break;
        }
      }

      // Start new section
      const level = headingMatch[1]?.length || 1;
      const heading = headingMatch[2]?.trim() || "";

      currentSection = {
        id: heading.toLowerCase().replace(/\s+/g, "-"),
        heading,
        level,
        startLine: lineIndex,
        isTeamManaged,
        content: "",
        hash: "",
      };
      currentContent = [];
    } else if (currentSection) {
      currentContent.push(line);
    } else if (!header && sections.length === 0) {
      // Lines before first section are part of header
      header += (header ? "\n" : "") + line;
    }
  }

  // Save last section
  if (currentSection) {
    currentSection.content = currentContent.join("\n").trim();
    currentSection.endLine = lines.length - 1;
    sections.push(currentSection as ParsedSection);
  }

  // Process footer
  footer = footerLines.join("\n");

  // Extract content hash from footer
  // Format: "Content Hash: sha256:xxx" or "Content Hash: xxx"
  const hashMatch = footer.match(
    /Content\s+Hash:\s*(sha256:[a-f0-9]+|[a-f0-9]+)/i,
  );
  if (hashMatch && hashMatch[1]) {
    const hashValue = hashMatch[1];
    // Ensure it has sha256: prefix
    contentHash = hashValue.toLowerCase().startsWith("sha256:")
      ? hashValue
      : `sha256:${hashValue}`;
  }

  // Team-managed markers already detected above during heading parsing

  // Compute hash for each section
  for (const section of sections) {
    section.hash = computeSectionHash(section.heading, section.content);
  }

  return {
    sections,
    header: header.trim(),
    footer: footer.trim(),
    contentHash,
  };
}

/**
 * Compute SHA-256 hash of section content
 * Used for change detection
 */
function computeSectionHash(heading: string, content: string): string {
  const normalized = `${heading}\n${content}`.trim();
  return createHash("sha256").update(normalized, "utf-8").digest("hex");
}
