/**
 * Generic Markdown Exporter
 * Base class for all link-based exporters (CLAUDE.md, WARP.md, etc.)
 *
 * Creates files with links to .aligntrue/rules/*.md instead of concatenated content.
 */

import type {
  ScopedExportRequest,
  ExportOptions,
  ExportResult,
  ExporterCapabilities,
} from "@aligntrue/plugin-contracts";
import type { RuleFile, RuleFrontmatter } from "@aligntrue/schema";
import { join } from "path";
import { ExporterBase } from "./index.js";

/**
 * Generic configurable markdown exporter with link-based output
 * Used as delegate for agent-specific exporters
 */
export class GenericMarkdownExporter extends ExporterBase {
  name: string;
  version = "1.0.0";
  capabilities: ExporterCapabilities = {
    multiFile: false, // Single-file format
    twoWaySync: false, // No longer supports two-way sync
    scopeAware: true, // Can filter by scope
    preserveStructure: false, // Link-based
    nestedDirectories: true, // Supports nested scope directories
  };

  private filename: string; // e.g., "CLAUDE.md", "WARP.md"
  private title: string; // e.g., "CLAUDE.md", "WARP.md"
  private description: string; // e.g., "for Claude Code", "for Warp"

  constructor(
    name: string,
    filename: string,
    title: string,
    description: string,
  ) {
    super();
    this.name = name;
    this.filename = filename;
    this.title = title;
    this.description = description;
  }

  override async export(
    request: ScopedExportRequest,
    options: ExportOptions,
  ): Promise<ExportResult> {
    const { outputDir, dryRun = false } = options;

    // Get rules from request (handles backward compatibility with pack)
    const rules = this.getRulesFromRequest(request);

    // Filter rules that should be exported to this agent
    const exportableRules = rules.filter((rule) =>
      this.shouldExportRule(rule, this.name),
    );

    if (exportableRules.length === 0) {
      return {
        success: true,
        filesWritten: [],
        contentHash: "",
      };
    }

    // Group rules by nested location
    const rulesByLocation = this.groupRulesByLocation(exportableRules);

    const allFilesWritten: string[] = [];
    const contentHashes: string[] = [];

    for (const [location, locationRules] of rulesByLocation.entries()) {
      // Determine output path
      const outputPath =
        location === ""
          ? join(outputDir, this.filename)
          : join(outputDir, location, this.filename);

      // Generate link-based content
      const content = this.generateLinkBasedContent(
        locationRules,
        location,
        outputDir,
      );

      // Always compute content hash (for dry-run to return meaningful hash)
      contentHashes.push(this.computeHash(content));

      // Write file
      const files = await this.writeFile(outputPath, content, dryRun, {
        ...options,
        force: true, // Always force overwrite for read-only exports
      });

      if (files.length > 0) {
        allFilesWritten.push(...files);
      }
    }

    const combinedHash =
      contentHashes.length > 0
        ? this.computeHash(contentHashes.sort().join(""))
        : "";

    return this.buildResult(allFilesWritten, combinedHash, []);
  }

  override translateFrontmatter(
    frontmatter: RuleFrontmatter,
  ): Record<string, unknown> {
    // Minimal frontmatter - just title and description
    const result: Record<string, unknown> = {};

    if (frontmatter["title"]) {
      result["title"] = frontmatter["title"];
    }

    if (frontmatter["description"]) {
      result["description"] = frontmatter["description"];
    }

    return result;
  }

  resetState(): void {
    // No state to reset
  }

  /**
   * Group rules by their nested_location
   */
  private groupRulesByLocation(rules: RuleFile[]): Map<string, RuleFile[]> {
    const byLocation = new Map<string, RuleFile[]>();

    for (const rule of rules) {
      const location = rule.frontmatter.nested_location || "";
      if (!byLocation.has(location)) {
        byLocation.set(location, []);
      }
      byLocation.get(location)!.push(rule);
    }

    return byLocation;
  }

  /**
   * Generate link-based content for the markdown file
   */
  private generateLinkBasedContent(
    rules: RuleFile[],
    location: string,
    _outputDir: string,
  ): string {
    const lines: string[] = [];

    // Read-only marker
    lines.push(`<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->`);
    lines.push("");

    // Header
    lines.push(`# ${this.title}`);
    lines.push("");
    lines.push(
      `This file contains links to the canonical rules in \`.aligntrue/rules/\`.`,
    );
    lines.push(`AI agents should follow these linked guidelines.`);
    lines.push("");

    // Group rules by category
    const rulesByCategory = this.groupRulesByCategory(rules);

    for (const [category, categoryRules] of rulesByCategory.entries()) {
      lines.push(`## ${category}`);
      lines.push("");

      for (const rule of categoryRules) {
        const title =
          rule.frontmatter.title || rule.filename.replace(/\.md$/, "");
        const description = rule.frontmatter.description || "";

        // Compute relative path from file to the rule file
        const rulesDir =
          location === "" ? ".aligntrue/rules" : `${location}/.aligntrue/rules`;
        const linkPath = `./${rulesDir}/${rule.filename}`;

        if (description) {
          lines.push(`- [${title}](${linkPath}) - ${description}`);
        } else {
          lines.push(`- [${title}](${linkPath})`);
        }
      }

      lines.push("");
    }

    return lines.join("\n");
  }

  /**
   * Group rules by category for organized output
   */
  private groupRulesByCategory(rules: RuleFile[]): Map<string, RuleFile[]> {
    const byCategory = new Map<string, RuleFile[]>();

    for (const rule of rules) {
      const category = rule.frontmatter.scope || "General";
      const displayCategory = this.formatCategoryName(category);

      if (!byCategory.has(displayCategory)) {
        byCategory.set(displayCategory, []);
      }
      byCategory.get(displayCategory)!.push(rule);
    }

    // Ensure "General" is first if it exists
    const sorted = new Map<string, RuleFile[]>();
    if (byCategory.has("General")) {
      sorted.set("General", byCategory.get("General")!);
    }
    for (const [cat, r] of byCategory) {
      if (cat !== "General") {
        sorted.set(cat, r);
      }
    }

    return sorted;
  }

  /**
   * Format category name for display
   */
  private formatCategoryName(scope: string): string {
    if (scope === "." || scope === "" || scope === "General") {
      return "General";
    }

    return scope
      .split("/")
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join(" / ");
  }
}

export default GenericMarkdownExporter;
