/**
 * Section parser utility for agent files
 * Parses existing agent files and extracts sections with metadata for merging
 */

import { createHash } from "crypto";

export interface ParsedSection {
  id: string; // Section heading as identifier
  hash: string; // Content hash for change detection
  heading: string; // Full heading text
  content: string; // Section body content
  level: number; // Heading level (1-6)
  startLine: number; // For debugging/diff
  endLine: number; // For debugging/diff
  isTeamManaged?: boolean; // Detected from markers
}

export interface ParsedFile {
  sections: ParsedSection[];
  header: string; // File header before first section
  footer: string; // File footer with hash/metadata
  contentHash: string | undefined; // Extracted from footer
}

/**
 * Parse AGENTS.md format
 * Extracts sections, header, footer, and content hash
 */
export function parseAgentsMd(content: string): ParsedFile {
  return parseMarkdownSections(content, {
    hasYamlFrontmatter: false,
    footerStart: "---",
  });
}

/**
 * Parse Cursor .mdc format
 * Handles YAML frontmatter and extracts sections
 */
export function parseCursorMdc(content: string): ParsedFile {
  return parseMarkdownSections(content, {
    hasYamlFrontmatter: true,
    footerStart: "---",
  });
}

/**
 * Parse generic markdown (CLAUDE.md, GEMINI.md, etc.)
 */
export function parseGenericMarkdown(content: string): ParsedFile {
  return parseMarkdownSections(content, {
    hasYamlFrontmatter: false,
    footerStart: "---",
  });
}

interface ParseOptions {
  hasYamlFrontmatter: boolean;
  footerStart: string;
}

/**
 * Core markdown section parser
 * Handles different markdown formats with configurable options
 */
function parseMarkdownSections(
  content: string,
  options: ParseOptions,
): ParsedFile {
  const lines = content.split("\n");
  const sections: ParsedSection[] = [];
  let header = "";
  let footer = "";
  let contentHash: string | undefined;

  let currentSection: Partial<ParsedSection> | null = null;
  let currentContent: string[] = [];
  let lineIndex = 0;
  let headerEndLine = 0;

  // Parse header (YAML frontmatter or file header before first section)
  if (options.hasYamlFrontmatter && lines[0]?.trim() === "---") {
    // Parse YAML frontmatter
    const headerLines: string[] = ["---"];
    lineIndex = 1;

    while (lineIndex < lines.length && lines[lineIndex]?.trim() !== "---") {
      headerLines.push(lines[lineIndex] || "");
      lineIndex++;
    }

    if (lineIndex < lines.length) {
      headerLines.push("---");
      lineIndex++;
    }

    header = headerLines.join("\n");
    headerEndLine = lineIndex;
  }

  // Skip file title heading if it looks like a file title
  // (e.g., "# AGENTS.md", "# CLAUDE.md", etc.)
  if (lineIndex < lines.length) {
    const firstLine = lines[lineIndex]?.trim() || "";
    if (
      firstLine.match(/^#\s+[A-Z][A-Z_-]*\.md$/i) ||
      firstLine.match(/^#\s+AGENTS\.md$/i)
    ) {
      // This looks like a file title, skip it
      lineIndex++;
    }
  }

  // Parse sections and content
  let inFooter = false;
  const footerLines: string[] = [];

  for (; lineIndex < lines.length; lineIndex++) {
    const line = lines[lineIndex] || "";

    // Check for footer start
    if (
      !inFooter &&
      line.trim() === options.footerStart &&
      lineIndex > headerEndLine
    ) {
      // Check if this looks like a footer (contains "Generated by AlignTrue" or "Content Hash")
      const remainingContent = lines.slice(lineIndex).join("\n");
      if (
        remainingContent.includes("Generated by AlignTrue") ||
        remainingContent.includes("Content Hash:")
      ) {
        inFooter = true;

        // Save current section if exists
        if (currentSection) {
          currentSection.content = currentContent.join("\n").trim();
          currentSection.endLine = lineIndex - 1;
          sections.push(currentSection as ParsedSection);
          currentSection = null;
          currentContent = [];
        }

        footerLines.push(line);
        continue;
      }
    }

    if (inFooter) {
      footerLines.push(line);
      continue;
    }

    // Check for heading
    const headingMatch = line.match(/^(#{1,6})\s+(.+?)(\s+ðŸ”’)?$/);

    if (headingMatch) {
      // Save previous section
      if (currentSection) {
        currentSection.content = currentContent.join("\n").trim();
        currentSection.endLine = lineIndex - 1;
        sections.push(currentSection as ParsedSection);
      }

      // Start new section
      const level = headingMatch[1]?.length || 1;
      const heading = headingMatch[2]?.trim() || "";
      const isTeamManaged = !!headingMatch[3];

      currentSection = {
        id: heading.toLowerCase().replace(/\s+/g, "-"),
        heading,
        level,
        startLine: lineIndex,
        isTeamManaged,
        content: "",
        hash: "",
      };
      currentContent = [];
    } else if (currentSection) {
      currentContent.push(line);
    } else if (!header && sections.length === 0) {
      // Lines before first section are part of header
      header += (header ? "\n" : "") + line;
    }
  }

  // Save last section
  if (currentSection) {
    currentSection.content = currentContent.join("\n").trim();
    currentSection.endLine = lines.length - 1;
    sections.push(currentSection as ParsedSection);
  }

  // Process footer
  footer = footerLines.join("\n");

  // Extract content hash from footer
  const hashMatch = footer.match(/Content Hash:\s*([a-f0-9:]+)/i);
  if (hashMatch) {
    contentHash = hashMatch[1];
  }

  // Check for team-managed markers in HTML comments
  for (const section of sections) {
    const sectionStartLine = section.startLine;
    if (sectionStartLine > 0) {
      const prevLine = lines[sectionStartLine - 1];
      if (
        prevLine?.includes("Team-managed") ||
        prevLine?.includes("team-managed")
      ) {
        section.isTeamManaged = true;
      }
    }
  }

  // Compute hash for each section
  for (const section of sections) {
    section.hash = computeSectionHash(section.heading, section.content);
  }

  return {
    sections,
    header: header.trim(),
    footer: footer.trim(),
    contentHash,
  };
}

/**
 * Compute SHA-256 hash of section content
 * Used for change detection
 */
function computeSectionHash(heading: string, content: string): string {
  const normalized = `${heading}\n${content}`.trim();
  return createHash("sha256").update(normalized, "utf-8").digest("hex");
}
