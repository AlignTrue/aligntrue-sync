import type { AlignTrueConfig } from "@aligntrue/core";

/**
 * Goose exporter
 * Exports AlignTrue rules to Goose .goosehints format
 */

import { join } from "path";
import type {
  ScopedExportRequest,
  ExportOptions,
  ExportResult,
  ResolvedScope,
} from "../types.js";
import type { AlignSection } from "@aligntrue/schema";
import type { ModeHints } from "@aligntrue/core";
import { computeContentHash, getSections } from "@aligntrue/schema";
import { ExporterBase } from "../base/index.js";
import {
  extractModeConfig,
  applyRulePrioritization,
  generateSessionPreface,
  wrapRuleWithMarkers,
  shouldIncludeRule,
} from "../utils/index.js";

interface ExporterState {
  allRules: Array<{ rule: AlignRule; scopePath: string }>;
  allSections: Array<{ section: AlignSection; scopePath: string }>;
  useSections: boolean;
}

export class GooseExporter extends ExporterBase {
  name = "goose";
  version = "1.0.0";

  private state: ExporterState = {
    allRules: [],
    allSections: [],
    useSections: false,
  };

  async export(
    request: ScopedExportRequest,
    options: ExportOptions,
  ): Promise<ExportResult> {
    const { scope, rules, pack } = request;
    const { outputDir, dryRun = false, config } = options;

    const sections = getSections(pack);
    if (
      this.state.allRules.length === 0 &&
      this.state.allSections.length === 0
    ) {
      this.state.useSections = sections.length > 0;
    }

    if ((!rules || rules.length === 0) && sections.length === 0) {
      return {
        success: true,
        filesWritten: [],
        contentHash: "",
      };
    }

    const scopePath = this.formatScopePath(scope);
    rules.forEach((rule) => {
      this.state.allRules.push({ rule, scopePath });
    });

    const outputPath = join(outputDir, ".goosehints");

    const { modeHints, maxBlocks, maxTokens } = extractModeConfig(
      this.name,
      config as AlignTrueConfig | undefined,
    );
    const { content, warnings } = this.generateGooseHintsContent(
      modeHints,
      maxBlocks,
      maxTokens,
      options.unresolvedPlugsCount,
    );

    const allRulesIR = this.state.allRules.map(({ rule }) => rule);
    const contentHash = computeContentHash({ rules: allRulesIR });

    const fidelityNotes = this.computeFidelityNotes(allRulesIR);

    const filesWritten = await this.writeFile(outputPath, content, dryRun);

    const result = this.buildResult(filesWritten, contentHash, fidelityNotes);

    if (warnings.length > 0) {
      result.warnings = warnings;
    }

    return result;
  }

  resetState(): void {
    this.state = {
      allRules: [],
      allSections: [],
      useSections: false,
    };
  }

  private formatScopePath(scope: ResolvedScope): string {
    if (scope.isDefault || scope.path === "." || scope.path === "") {
      return "all files";
    }
    return scope.path;
  }

  private generateGooseHintsContent(
    modeHints: ModeHints,
    maxBlocks: number,
    maxTokens: number,
    unresolvedPlugs?: number,
  ): { content: string; warnings: string[] } {
    const lines: string[] = [];

    lines.push("# Goose Hints");
    lines.push("# Generated by AlignTrue");
    lines.push("");

    // Add session preface (as comments for plain text format)
    const prefaceLines = generateSessionPreface(modeHints);
    if (prefaceLines.length > 0) {
      prefaceLines.forEach((line) => lines.push(`# ${line}`));
      lines.push("");
    }

    // Apply prioritization
    const allRules = this.state.allRules.map(({ rule }) => rule);
    const { includedIds, warnings } = applyRulePrioritization(
      allRules,
      modeHints,
      maxBlocks,
      maxTokens,
    );

    // Generate rule sections
    this.state.allRules.forEach(({ rule, scopePath }) => {
      if (!shouldIncludeRule(rule.id, includedIds)) {
        return;
      }

      // Build rule content
      const ruleLines: string[] = [];
      ruleLines.push(`# ${rule.id} (${rule.severity.toUpperCase()})`);
      if (scopePath) {
        ruleLines.push(`# Scope: ${scopePath}`);
      }
      if (rule.guidance) {
        ruleLines.push("");
        rule.guidance
          .trim()
          .split("\n")
          .forEach((line) => {
            ruleLines.push(line);
          });
      }
      ruleLines.push("");
      ruleLines.push("---");

      // Wrap with markers
      const ruleContent = ruleLines.join("\n");
      lines.push(wrapRuleWithMarkers(rule, ruleContent, modeHints));
      lines.push("");
    });

    const allRulesIR = this.state.allRules.map(({ rule }) => rule);
    const contentHash = computeContentHash({ rules: allRulesIR });

    lines.push(`# Content Hash: ${contentHash}`);

    if (unresolvedPlugs !== undefined && unresolvedPlugs > 0) {
      lines.push(`# Unresolved Plugs: ${unresolvedPlugs}`);
    }

    return { content: lines.join("\n"), warnings };
  }

  /**
   * Compute fidelity notes for unmapped fields (custom for Goose)
   * Overrides base class to add Goose-specific messages
   */
  override computeFidelityNotes(rules: AlignRule[]): string[] {
    const notes: string[] = [];
    const unmappedFields = new Set<string>();

    rules.forEach((rule) => {
      if (rule.check) {
        unmappedFields.add("check");
      }
      if (rule.autofix) {
        unmappedFields.add("autofix");
      }
    });

    if (unmappedFields.has("check")) {
      notes.push(
        "Machine-checkable rules (check) not represented in .goosehints format",
      );
    }
    if (unmappedFields.has("autofix")) {
      notes.push("Autofix hints not represented in .goosehints format");
    }

    return notes;
  }
}

export default GooseExporter;
