/**
 * Tests for AGENTS.md exporter
 * Validates v1 format generation, scope merging, fidelity tracking, and snapshot outputs
 */

import { describe, it, expect, beforeEach } from "vitest";
import { createHash } from "crypto";
import { join } from "path";
import { AgentsMdExporter } from "../src/agents-md/index.js";
import { loadFixture } from "./helpers/test-fixtures.js";
import type {
  ScopedExportRequest,
  ExportOptions,
  ResolvedScope,
} from "@aligntrue/plugin-contracts";
import type { AlignPack, AlignSection } from "@aligntrue/schema";

/**
 * Generate a stable fingerprint for tests
 */
function generateFingerprint(heading: string, content: string): string {
  const combined = `${heading}::${content}`;
  return createHash("sha256").update(combined).digest("hex").substring(0, 16);
}

const FIXTURES_DIR = join(import.meta.dirname, "fixtures", "agents-md");

// Helper to create mock scope with optional overrides
function createMockScope(
  path: string = ".",
  isDefault: boolean = true,
): ResolvedScope {
  return {
    path,
    normalizedPath: path,
    include: ["**/*"],
    exclude: [],
    isDefault,
  };
}

// Helper to create scoped export request
function createRequest(
  scope: ResolvedScope,
  sections: AlignSection[],
): ScopedExportRequest {
  const pack: AlignPack = {
    id: "test-pack",
    version: "1.0.0",
    spec_version: "1",
    sections,
  };

  return {
    scope,
    pack,
    outputPath: "/test/output",
  };
}

describe("AgentsMdExporter", () => {
  let exporter: AgentsMdExporter;
  let options: ExportOptions;

  beforeEach(() => {
    exporter = new AgentsMdExporter();
    options = {
      outputDir: "/test/output",
      dryRun: true, // Default to dry-run for tests
    };
  });

  describe("Basic functionality", () => {
    it("implements ExporterPlugin interface", () => {
      expect(exporter.name).toBe("agents-md");
      expect(exporter.version).toBe("1.0.0");
      expect(typeof exporter.export).toBe("function");
    });

    it("exports single rule successfully", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result = await exporter.export(request, options);

      expect(result.success).toBe(true);
      expect(result.filesWritten).toEqual([]);
      expect(result.contentHash).toBeTruthy();
      expect(result.contentHash).toMatch(/^[a-f0-9]{64}$/);
    });

    it("exports multiple rules successfully", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "multiple-rules.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result = await exporter.export(request, options);

      expect(result.success).toBe(true);
      expect(result.contentHash).toBeTruthy();
    });

    it("handles empty rules array", async () => {
      const scope = createMockScope();
      const request = createRequest(scope, []);

      const result = await exporter.export(request, options);

      expect(result.success).toBe(true);
      expect(result.filesWritten).toEqual([]);
      expect(result.contentHash).toBe("");
    });
  });

  describe("Format validation", () => {
    it("generates v1 header with version marker", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const _result = await exporter.export(request, options);

      // Access private method for testing (via type assertion)
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toContain("# AGENTS.md");
      expect(content).toContain("**Version:** v1");
      expect(content).toContain("**Generated by:** AlignTrue");
      expect(content).toContain(
        "This file contains rules and guidance for AI coding agents.",
      );
    });

    it("maps severity to plain text labels (ERROR, WARN, INFO)", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "all-severities.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toContain("**Severity:** ERROR");
      expect(content).toContain("**Severity:** WARN");
      expect(content).toContain("**Severity:** INFO");
    });

    it("includes rule ID and scope paths in each section", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toContain("## Rule: testing.require-tests");
      expect(content).toContain("**ID:** testing.require-tests");
      expect(content).toContain("**Scope:**");
    });

    it("separates rules with horizontal lines", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "multiple-rules.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      // Should have separators between rules
      const separators = content.match(/\n---\n\n/g);
      expect(separators).toBeTruthy();
      expect(separators!.length).toBeGreaterThanOrEqual(2); // Between rules
    });

    it("generates footer with content hash and fidelity notes", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result = await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toContain("**Generated by AlignTrue**");
      expect(content).toContain(`Content Hash: ${result.contentHash}`);
    });
  });

  describe("Scope merging", () => {
    it("merges multiple scopes into single file", async () => {
      exporter.resetState();

      // First scope
      const scope1 = createMockScope("backend", false);
      const sections1: AlignSection[] = [
        {
          heading: "backend.api-tests",
          level: 2,
          content: "API tests required",
          fingerprint: generateFingerprint(
            "backend.api-tests",
            "API tests required",
          ),
        },
      ];
      const request1 = createRequest(scope1, sections1);
      await exporter.export(request1, options);

      // Second scope
      const scope2 = createMockScope("frontend", false);
      const sections2: AlignSection[] = [
        {
          heading: "frontend.component-tests",
          level: 2,
          content: "Component tests recommended",
          fingerprint: generateFingerprint(
            "frontend.component-tests",
            "Component tests recommended",
          ),
        },
      ];
      const request2 = createRequest(scope2, sections2);
      await exporter.export(request2, options);

      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      // Both rules should be present
      expect(content).toContain("## Rule: backend.api-tests");
      expect(content).toContain("## Rule: frontend.component-tests");
    });

    it("preserves scope path information in rule metadata", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "multiple-scopes.yaml");
      const scope = createMockScope("backend", false);
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      // Scope path should be included
      expect(content).toContain("**Scope:** backend");
    });

    it("handles default scope correctly", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope(".", true);
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      // Default scope should show "all files" or just applies_to patterns
      expect(content).toMatch(/\*\*Scope:\*\*.*\*\*\/\*\.ts/);
    });
  });

  describe("Fidelity tracking", () => {
    it("tracks unmapped fields (check, autofix)", async () => {
      // Using fixture with vendor fields that have cross-agent data
      const { sections } = loadFixture(FIXTURES_DIR, "with-vendor-fields.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result = await exporter.export(request, options);

      expect(result.fidelityNotes).toBeDefined();
      expect(result.fidelityNotes).toContain(
        "Machine-checkable rules (check) not represented in AGENTS.md format",
      );
      expect(result.fidelityNotes).toContain(
        "Autofix hints not represented in AGENTS.md format",
      );
    });

    it("tracks vendor.* fields (cursor, copilot, etc.) in fidelity notes", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "with-vendor-fields.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result = await exporter.export(request, options);

      expect(result.fidelityNotes).toBeDefined();
      expect(
        result.fidelityNotes!.some((note) =>
          note.includes(
            "Vendor-specific metadata preserved but not active in universal format",
          ),
        ),
      ).toBe(true);
      expect(
        result.fidelityNotes!.some(
          (note) =>
            note.includes("copilot") &&
            note.includes("cursor") &&
            note.includes("vscode"),
        ),
      ).toBe(true);
    });
  });

  describe("Content hash", () => {
    it("computes deterministic hash from canonical IR", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result1 = await exporter.export(request, options);

      // Reset and export again
      exporter.resetState();
      const result2 = await exporter.export(request, options);

      expect(result1.contentHash).toBe(result2.contentHash);
    });

    it("hash consistent across multiple exports of same IR", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "multiple-rules.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const hashes: string[] = [];
      for (let i = 0; i < 3; i++) {
        exporter.resetState();
        const result = await exporter.export(request, options);
        hashes.push(result.contentHash);
      }

      expect(hashes[0]).toBe(hashes[1]);
      expect(hashes[1]).toBe(hashes[2]);
    });
  });

  describe("File operations", () => {
    it("writes to correct location (workspace root / AGENTS.md)", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      // In dry-run mode, verify path construction is correct
      const result = await exporter.export(request, {
        outputDir: "/workspace",
        dryRun: true,
      });

      // Verify it would write to AGENTS.md at root (not scoped directory)
      // In actual write mode, filesWritten would be ['/workspace/AGENTS.md']
      expect(result.success).toBe(true);

      // Also verify it's not writing to a scope-based subdirectory
      // (unlike Cursor exporter which writes to .cursor/rules/)
      // Note: In dry-run mode, filesWritten is empty, so we verify path construction
      // would produce platform-agnostic path that ends with AGENTS.md
      if (result.filesWritten.length > 0) {
        expect(result.filesWritten[0].replace(/\\/g, "/")).toMatch(
          /\/AGENTS\.md$/,
        );
      } else {
        // In dry-run, verify expected path structure would be correct
        const expectedPath = join("/workspace", "AGENTS.md").replace(
          /\\/g,
          "/",
        );
        expect(expectedPath).toBe("/workspace/AGENTS.md");
      }
    });

    it("dry-run mode returns content without writing", async () => {
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      const result = await exporter.export(request, {
        ...options,
        dryRun: true,
      });

      expect(result.success).toBe(true);
      expect(result.filesWritten).toEqual([]);
      expect(result.contentHash).toBeTruthy();
    });
  });

  describe("Snapshot tests", () => {
    it("single rule golden output", async () => {
      exporter.resetState();
      const { sections } = loadFixture(FIXTURES_DIR, "single-rule.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toMatchSnapshot();
    });

    it("multiple rules golden output", async () => {
      exporter.resetState();
      const { sections } = loadFixture(FIXTURES_DIR, "multiple-rules.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toMatchSnapshot();
    });

    it("multiple scopes merged output", async () => {
      exporter.resetState();
      const { sections } = loadFixture(FIXTURES_DIR, "multiple-scopes.yaml");

      // Simulate different scopes - use all sections with one scope
      // (original test accessed private method, now simplified)
      const scope1 = createMockScope("backend", false);
      const request1 = createRequest(scope1, sections);
      await exporter.export(request1, options);

      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toMatchSnapshot();
    });

    it("all severities (ERROR, WARN, INFO) output", async () => {
      exporter.resetState();
      const { sections } = loadFixture(FIXTURES_DIR, "all-severities.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toMatchSnapshot();
    });

    it("with vendor fields (fidelity notes included)", async () => {
      exporter.resetState();
      const { sections } = loadFixture(FIXTURES_DIR, "with-vendor-fields.yaml");
      const scope = createMockScope();
      const request = createRequest(scope, sections);

      await exporter.export(request, options);
      const content = (exporter as any).generateAgentsMdContent(
        "metadata_only",
        1000,
        100000,
      ).content;

      expect(content).toMatchSnapshot();
    });
  });
});
