/**
 * Gemini MD exporter tests
 */

import { describe, it, expect, beforeEach } from "vitest";
import { ExporterRegistry } from "../src/registry.js";
import type { AlignPack } from "@aligntrue/schema";
import { dirname, join } from "path";
import { fileURLToPath } from "url";
import { mkdirSync, rmSync, readFileSync } from "fs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Helper to create request with pack
function createTestRequest(rules: any[], scope: any): any {
  const pack: AlignPack = {
    id: "test-pack",
    version: "1.0.0",
    spec_version: "1",
    rules,
  };
  return { scope, rules, pack };
}

describe("GeminiMdExporter", () => {
  let registry: ExporterRegistry;
  const testRoot = join(__dirname, "../.test-output-gemini");

  beforeEach(() => {
    registry = new ExporterRegistry();
    // Clean test output
    rmSync(testRoot, { recursive: true, force: true });
    mkdirSync(testRoot, { recursive: true });
  });

  it("should discover gemini-md manifest", () => {
    const srcPath = join(__dirname, "../src");
    const manifests = registry.discoverAdapters(srcPath);

    const hasGeminiMd = manifests.some((p) => p.includes("gemini-md"));
    expect(hasGeminiMd).toBe(true);
  });

  it("should load gemini-md manifest", () => {
    const manifestPath = join(__dirname, "../src/gemini-md/manifest.json");
    const manifest = registry.loadManifest(manifestPath);

    expect(manifest.name).toBe("gemini-md");
    expect(manifest.version).toBe("1.0.0");
    expect(manifest.outputs).toContain("GEMINI.md");
    expect(manifest.handler).toBe("./index.ts");
  });

  it("should register and export GEMINI.md", async () => {
    const manifestPath = join(__dirname, "../src/gemini-md/manifest.json");
    await registry.registerFromManifest(manifestPath);

    const exporter = registry.get("gemini-md");
    expect(exporter).toBeDefined();
    expect(exporter?.name).toBe("gemini-md");
    expect(exporter?.version).toBe("1.0.0");

    // Test export
    const result = await exporter!.export(
      createTestRequest(
        [
          {
            id: "test-rule",
            severity: "error",
            guidance: "This is a test rule for Gemini",
          },
        ],
        { root: ".", applies_to: ["**/*.ts"] },
      ),
      { outputDir: testRoot, dryRun: false },
    );

    expect(result.success).toBe(true);
    expect(result.filesWritten).toHaveLength(1);
    expect(result.filesWritten[0]).toMatch(/GEMINI\.md$/);
    expect(result.contentHash).toMatch(/^[a-f0-9]{64}$/);

    const content = readFileSync(result.filesWritten[0], "utf-8");
    expect(content).toContain("# GEMINI.md");
    expect(content).toContain("**Version:** v1");
    expect(content).toContain("**Generated by:** AlignTrue");
    expect(content).toContain(
      "This file contains rules and guidance for Google Gemini",
    );
    expect(content).toContain("## Rule: test-rule");
    expect(content).toContain("**ID:** test-rule");
    expect(content).toContain("**Severity:** ERROR");
    expect(content).toContain("This is a test rule for Gemini");
    expect(content).toContain("Content Hash:");
    expect(content).toContain("**Generated by AlignTrue**");
  });

  it("should produce deterministic output", async () => {
    const manifestPath = join(__dirname, "../src/gemini-md/manifest.json");
    await registry.registerFromManifest(manifestPath);
    const exporter = registry.get("gemini-md");

    const rules = [
      {
        id: "rule-a",
        severity: "error" as const,
        guidance: "First rule",
      },
      {
        id: "rule-b",
        severity: "warn" as const,
        guidance: "Second rule",
      },
    ];

    const scope = { root: ".", applies_to: ["**/*.ts"] };

    // Export twice, resetting state between exports
    const result1 = await exporter!.export(
      {
        scope,
        rules,
        pack: { id: "test-pack", version: "1.0.0", spec_version: "1", rules },
      },
      { outputDir: join(testRoot, "run1"), dryRun: false },
    );
    if (exporter && "resetState" in exporter) {
      (exporter as any).resetState();
    }

    const result2 = await exporter!.export(
      {
        scope,
        rules,
        pack: { id: "test-pack", version: "1.0.0", spec_version: "1", rules },
      },
      { outputDir: join(testRoot, "run2"), dryRun: false },
    );

    // Content hashes should match
    expect(result1.contentHash).toBe(result2.contentHash);

    // File contents should match
    const content1 = readFileSync(result1.filesWritten[0], "utf-8");
    const content2 = readFileSync(result2.filesWritten[0], "utf-8");
    expect(content1).toBe(content2);
  });

  it("should handle empty rules gracefully", async () => {
    const manifestPath = join(__dirname, "../src/gemini-md/manifest.json");
    await registry.registerFromManifest(manifestPath);
    const exporter = registry.get("gemini-md");

    const rules: any[] = [];
    const result = await exporter!.export(
      {
        scope: { root: ".", applies_to: ["**/*.ts"] },
        rules,
        pack: { id: "test-pack", version: "1.0.0", spec_version: "1", rules },
      },
      { outputDir: testRoot, dryRun: false },
    );

    expect(result.success).toBe(true);
    expect(result.filesWritten).toHaveLength(0);
  });

  it("should include unresolved plugs count when provided", async () => {
    const manifestPath = join(__dirname, "../src/gemini-md/manifest.json");
    await registry.registerFromManifest(manifestPath);
    const exporter = registry.get("gemini-md");

    const rules = [
      {
        id: "test-rule",
        severity: "error",
        guidance: "Test",
      },
    ];
    const result = await exporter!.export(
      {
        scope: { root: ".", applies_to: ["**/*.ts"] },
        rules,
        pack: { id: "test-pack", version: "1.0.0", spec_version: "1", rules },
      },
      { outputDir: testRoot, dryRun: false, unresolvedPlugsCount: 3 },
    );

    expect(result.success).toBe(true);
    const content = readFileSync(result.filesWritten[0], "utf-8");
    expect(content).toContain("Unresolved Plugs: 3");
  });
});
