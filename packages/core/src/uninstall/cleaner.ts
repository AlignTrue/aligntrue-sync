/**
 * Cleaner for AlignTrue uninstall
 *
 * Handles:
 * - Converting exported files to editable (removing READ-ONLY markers)
 * - Deleting exported files
 * - Deleting .aligntrue directory
 * - Removing gitignore entries
 */

import {
  existsSync,
  readFileSync,
  writeFileSync,
  rmSync,
  unlinkSync,
} from "fs";
import { join, dirname } from "path";
import type {
  UninstallOptions,
  UninstallResult,
  UninstallPreview,
  DetectionResult,
} from "./types.js";
import { BackupManager } from "../backup/index.js";

/**
 * Pattern to match READ-ONLY markers in exported files
 * Captures the entire marker block including the HTML comment
 */
const READ_ONLY_MARKER_PATTERN =
  /<!--\s*READ-ONLY:\s*This file is auto-generated by AlignTrue\.[\s\S]*?-->\s*\n?/g;

/**
 * Gitignore markers used by AlignTrue
 */
const GITIGNORE_MARKERS = [
  {
    start: "# START AlignTrue Generated Files",
    end: "# END AlignTrue Generated Files",
  },
  {
    start: "# START AlignTrue Gitignored Rules",
    end: "# END AlignTrue Gitignored Rules",
  },
  // Legacy markers
  {
    start: "# START AlignTrue Private Rules",
    end: "# END AlignTrue Private Rules",
  },
];

/**
 * Generate a preview of what uninstall would do
 */
export function previewUninstall(
  detection: DetectionResult,
  options: UninstallOptions,
): UninstallPreview {
  const preview: UninstallPreview = {
    toConvert: [],
    toDelete: [],
    toDeleteDirs: [],
    toRemoveFromGitignore: [],
    toKeep: [],
  };

  // Handle exported files based on exportHandling option
  for (const file of detection.exportedFiles) {
    switch (options.exportHandling) {
      case "convert":
        if (file.hasReadOnlyMarker) {
          preview.toConvert.push(file.path);
        } else {
          preview.toKeep.push(file.path);
        }
        break;
      case "delete":
        preview.toDelete.push(file.path);
        break;
      case "skip":
        preview.toKeep.push(file.path);
        break;
    }
  }

  // Handle source directory based on sourceHandling option
  if (options.sourceHandling === "delete") {
    if (detection.aligntrueDir) {
      preview.toDeleteDirs.push(".aligntrue");
    }
    // Lockfile is at root level
    if (detection.lockfile) {
      preview.toDelete.push(detection.lockfile.path);
    }
  } else {
    // Keep source but still delete lockfile if it exists
    if (detection.lockfile) {
      preview.toDelete.push(detection.lockfile.path);
    }
    // Keep the .aligntrue directory
    if (detection.aligntrueDir) {
      for (const file of detection.sourceFiles) {
        preview.toKeep.push(file.path);
      }
      for (const file of detection.configFiles) {
        preview.toKeep.push(file.path);
      }
    }
  }

  // Gitignore entries are always removed
  preview.toRemoveFromGitignore = detection.gitignoreEntries;

  return preview;
}

/**
 * Execute the uninstall operation
 */
export async function executeUninstall(
  detection: DetectionResult,
  options: UninstallOptions,
): Promise<UninstallResult> {
  const cwd = options.cwd || process.cwd();
  const result: UninstallResult = {
    success: false,
    convertedFiles: [],
    deletedFiles: [],
    deletedDirectories: [],
    removedGitignoreEntries: [],
    backupTimestamp: "",
    warnings: [],
  };

  try {
    // Step 1: Create safety backup (always, unless dry-run)
    if (!options.dryRun && detection.isInstalled) {
      const backup = BackupManager.createBackup({
        cwd,
        created_by: "uninstall",
        notes: "Safety backup before uninstall",
        action: "uninstall",
      });
      result.backupTimestamp = backup.timestamp;
    }

    // Step 2: Handle exported files
    for (const file of detection.exportedFiles) {
      const filePath = join(cwd, file.path);

      switch (options.exportHandling) {
        case "convert":
          if (file.hasReadOnlyMarker) {
            if (!options.dryRun) {
              convertToEditable(filePath);
            }
            result.convertedFiles.push(file.path);
          }
          break;

        case "delete":
          if (!options.dryRun) {
            try {
              unlinkSync(filePath);
              result.deletedFiles.push(file.path);
            } catch (err) {
              result.warnings.push(
                `Failed to delete ${file.path}: ${err instanceof Error ? err.message : String(err)}`,
              );
            }
          } else {
            result.deletedFiles.push(file.path);
          }
          break;

        case "skip":
          // Do nothing
          break;
      }
    }

    // Step 3: Clean up empty export directories after file deletion
    if (options.exportHandling === "delete" && !options.dryRun) {
      cleanupEmptyExportDirectories(cwd, detection.exportedFiles);
    }

    // Step 4: Handle source directory
    if (options.sourceHandling === "delete" && detection.aligntrueDir) {
      if (!options.dryRun) {
        try {
          rmSync(detection.aligntrueDir, { recursive: true, force: true });
          result.deletedDirectories.push(".aligntrue");
        } catch (err) {
          result.warnings.push(
            `Failed to delete .aligntrue directory: ${err instanceof Error ? err.message : String(err)}`,
          );
        }
      } else {
        result.deletedDirectories.push(".aligntrue");
      }
    }

    // Step 5: Delete lockfile (always delete if present)
    if (detection.lockfile) {
      const lockfilePath = join(cwd, detection.lockfile.path);
      if (!options.dryRun) {
        try {
          unlinkSync(lockfilePath);
          result.deletedFiles.push(detection.lockfile.path);
        } catch (err) {
          result.warnings.push(
            `Failed to delete lockfile: ${err instanceof Error ? err.message : String(err)}`,
          );
        }
      } else {
        result.deletedFiles.push(detection.lockfile.path);
      }
    }

    // Step 6: Remove gitignore entries
    if (detection.gitignoreEntries.length > 0) {
      if (!options.dryRun) {
        const removed = removeGitignoreEntries(cwd);
        result.removedGitignoreEntries = removed;
      } else {
        result.removedGitignoreEntries = detection.gitignoreEntries;
      }
    }

    result.success = true;
  } catch (err) {
    result.error =
      err instanceof Error ? err.message : "Unknown error during uninstall";
  }

  return result;
}

/**
 * Convert an exported file to editable by removing the READ-ONLY marker
 */
function convertToEditable(filePath: string): void {
  if (!existsSync(filePath)) {
    return;
  }

  const content = readFileSync(filePath, "utf-8");
  const converted = content.replace(READ_ONLY_MARKER_PATTERN, "").trimStart();
  writeFileSync(filePath, converted, "utf-8");
}

/**
 * Remove AlignTrue-managed sections from .gitignore
 */
function removeGitignoreEntries(cwd: string): string[] {
  const gitignorePath = join(cwd, ".gitignore");
  if (!existsSync(gitignorePath)) {
    return [];
  }

  let content = readFileSync(gitignorePath, "utf-8");
  const removedEntries: string[] = [];

  // Remove each marker section
  for (const marker of GITIGNORE_MARKERS) {
    const escapedStart = escapeRegex(marker.start);
    const escapedEnd = escapeRegex(marker.end);
    // Safe: marker.start and marker.end are hardcoded constants, not user input
    // eslint-disable-next-line security/detect-non-literal-regexp
    const regex = new RegExp(`${escapedStart}[\\s\\S]*?${escapedEnd}\\n?`, "g");

    // Extract entries before removing
    const sectionMatch = regex.exec(content);
    if (sectionMatch) {
      const sectionContent = sectionMatch[0];
      const entries = sectionContent
        .split("\n")
        .map((line) => line.trim())
        .filter(
          (line) =>
            line &&
            !line.startsWith("#") &&
            line !== marker.start &&
            line !== marker.end,
        );
      removedEntries.push(...entries);
    }

    // Reset regex and remove the section
    // Safe: marker.start and marker.end are hardcoded constants, not user input
    // eslint-disable-next-line security/detect-non-literal-regexp
    const removeRegex = new RegExp(
      `${escapedStart}[\\s\\S]*?${escapedEnd}\\n?`,
      "g",
    );
    content = content.replace(removeRegex, "");
  }

  // Also remove any "# AlignTrue generated" single-line comments with their entries
  const lines = content.split("\n");
  const filteredLines: string[] = [];
  let skipNext = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line && line.trim() === "# AlignTrue generated") {
      skipNext = true;
      continue;
    }
    if (skipNext && line && line.trim() && !line.startsWith("#")) {
      removedEntries.push(line.trim());
      skipNext = false;
      continue;
    }
    skipNext = false;
    filteredLines.push(line ?? "");
  }

  // Clean up excessive blank lines
  const cleanedContent = filteredLines
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trim();

  writeFileSync(gitignorePath, cleanedContent + "\n", "utf-8");

  return removedEntries;
}

/**
 * Clean up empty directories after file deletion
 */
function cleanupEmptyExportDirectories(
  cwd: string,
  deletedFiles: { path: string }[],
): void {
  // Get unique directories
  const dirs = new Set<string>();
  for (const file of deletedFiles) {
    const dir = dirname(file.path);
    if (dir !== ".") {
      dirs.add(dir);
    }
  }

  // Sort by depth (deepest first) to ensure child dirs are removed before parents
  const sortedDirs = Array.from(dirs).sort(
    (a, b) => b.split("/").length - a.split("/").length,
  );

  for (const dir of sortedDirs) {
    const dirPath = join(cwd, dir);
    try {
      if (existsSync(dirPath) && isEmptyDirectory(dirPath)) {
        rmSync(dirPath, { recursive: true, force: true });
      }
    } catch {
      // Ignore errors - directory might not be empty or might not exist
    }
  }
}

/**
 * Check if a directory is empty
 */
function isEmptyDirectory(dirPath: string): boolean {
  try {
    const entries = require("fs").readdirSync(dirPath);
    return entries.length === 0;
  } catch {
    return false;
  }
}

/**
 * Escape special regex characters
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
