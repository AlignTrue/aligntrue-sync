/**
 * Detector for AlignTrue files in a workspace
 *
 * Finds all files created by AlignTrue including:
 * - Exported agent files (.cursor/rules/*.mdc, AGENTS.md, etc.)
 * - Source files (.aligntrue/rules/*.md)
 * - Configuration (.aligntrue/config.yaml)
 * - Lockfile (.aligntrue/lock.json or .aligntrue.lock.json for legacy)
 * - Cache (.aligntrue/.cache/)
 * - Backups (.aligntrue/.backups/)
 */

import { existsSync, readFileSync, readdirSync, statSync } from "fs";
import { join, relative } from "path";
import type { DetectedFile, DetectionResult } from "./types.js";

/**
 * Pattern to match READ-ONLY markers in exported files
 */
const READ_ONLY_MARKER_PATTERN =
  /<!--\s*READ-ONLY:\s*This file is auto-generated by AlignTrue\./;

/**
 * Known export file patterns from AlignTrue exporters
 */
const EXPORT_PATTERNS = [
  // Cursor
  { dir: ".cursor/rules", ext: ".mdc" },
  // AGENTS.md (various agents)
  { file: "AGENTS.md" },
  // Cline
  { dir: ".clinerules" },
  // AugmentCode
  { dir: ".augment/rules" },
  // OpenHands
  { dir: ".openhands/microagents" },
  // Root MCP
  { file: ".mcp.json" },
  // VS Code MCP
  { file: ".vscode/mcp.json" },
  // Cursor MCP
  { file: ".cursor/mcp.json" },
  // Amazon Q
  { dir: ".amazonq" },
  // Windsurf
  { dir: ".windsurf/rules" },
  { file: ".windsurf/mcp.json" },
  // Zed
  { file: ".zed/mcp.json" },
  // Aider
  { file: ".aider.conf.yml" },
  // Copilot
  { file: ".github/copilot-instructions.md" },
  // Roo Code
  { dir: ".roo/rules" },
  // Kilo Code
  { dir: ".kilo/rules" },
  // Goose
  { dir: ".goose/rules" },
  // Gemini
  { file: "GEMINI.md" },
  { file: ".gemini/settings.json" },
  // Qwen
  { file: ".qwen/config.yaml" },
  // Firebender
  { dir: ".firebender/rules" },
  // Jules
  { file: "JULES.md" },
  // Junie
  { dir: ".junie/rules" },
  // OpenCode
  { file: ".opencode/instructions.md" },
  // Claude
  { file: "CLAUDE.md" },
  // Firebase Studio
  { dir: ".firebase/rules" },
  // AMP
  { file: "AMP.md" },
  // Trae AI
  { dir: ".trae/rules" },
  // Warp
  { file: ".warp/rules.md" },
  // Crush
  { dir: ".crush/rules" },
  // Kiro
  { dir: ".kiro/rules" },
];

/**
 * Gitignore markers used by AlignTrue
 */
const GITIGNORE_MARKERS = {
  generated: {
    start: "# START AlignTrue Generated Files",
    end: "# END AlignTrue Generated Files",
  },
  gitignored: {
    start: "# START AlignTrue Gitignored Rules",
    end: "# END AlignTrue Gitignored Rules",
  },
  legacy: {
    start: "# START AlignTrue Private Rules",
    end: "# END AlignTrue Private Rules",
  },
};

/**
 * Detect all AlignTrue files in a workspace
 */
export function detectAlignTrueFiles(cwd: string): DetectionResult {
  const aligntrueDir = join(cwd, ".aligntrue");
  const isInstalled = existsSync(aligntrueDir);

  const result: DetectionResult = {
    isInstalled,
    aligntrueDir: isInstalled ? aligntrueDir : null,
    exportedFiles: [],
    sourceFiles: [],
    configFiles: [],
    lockfile: null,
    cacheDir: null,
    backupsDir: null,
    gitignoreEntries: [],
  };

  if (!isInstalled) {
    return result;
  }

  // Detect exported agent files
  result.exportedFiles = detectExportedFiles(cwd);

  // Detect source files
  result.sourceFiles = detectSourceFiles(cwd);

  // Detect config files
  result.configFiles = detectConfigFiles(cwd);

  // Detect lockfile
  result.lockfile = detectLockfile(cwd);

  // Detect cache directory
  result.cacheDir = detectCacheDir(cwd);

  // Detect backups directory
  result.backupsDir = detectBackupsDir(cwd);

  // Detect gitignore entries
  result.gitignoreEntries = detectGitignoreEntries(cwd);

  return result;
}

/**
 * Detect exported agent files
 */
function detectExportedFiles(cwd: string): DetectedFile[] {
  const files: DetectedFile[] = [];

  for (const pattern of EXPORT_PATTERNS) {
    if ("file" in pattern && pattern.file) {
      const filePath = join(cwd, pattern.file);
      if (existsSync(filePath)) {
        const stat = statSync(filePath);
        if (stat.isFile()) {
          const hasMarker = checkForReadOnlyMarker(filePath);
          files.push({
            path: pattern.file,
            type: "export",
            hasReadOnlyMarker: hasMarker,
            size: stat.size,
          });
        }
      }
    }

    if ("dir" in pattern && pattern.dir) {
      const dirPath = join(cwd, pattern.dir);
      if (existsSync(dirPath)) {
        const stat = statSync(dirPath);
        if (stat.isDirectory()) {
          // Scan directory for files
          const dirFiles = scanDirectory(dirPath, pattern.ext);
          for (const file of dirFiles) {
            const relativePath = relative(cwd, file.path);
            const hasMarker = checkForReadOnlyMarker(file.path);
            files.push({
              path: relativePath.replace(/\\/g, "/"),
              type: "export",
              hasReadOnlyMarker: hasMarker,
              size: file.size,
            });
          }
        }
      }
    }
  }

  return files;
}

/**
 * Check if a file has the READ-ONLY marker
 */
function checkForReadOnlyMarker(filePath: string): boolean {
  try {
    // Read only first 500 bytes - marker should be at the top
    const content = readFileSync(filePath, "utf-8").slice(0, 500);
    return READ_ONLY_MARKER_PATTERN.test(content);
  } catch {
    return false;
  }
}

/**
 * Scan a directory for files, optionally filtering by extension
 */
function scanDirectory(
  dir: string,
  ext?: string,
): { path: string; size: number }[] {
  const files: { path: string; size: number }[] = [];

  try {
    const entries = readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      if (entry.isFile()) {
        if (!ext || entry.name.endsWith(ext)) {
          const stat = statSync(fullPath);
          files.push({ path: fullPath, size: stat.size });
        }
      } else if (entry.isDirectory()) {
        // Recurse into subdirectories
        files.push(...scanDirectory(fullPath, ext));
      }
    }
  } catch {
    // Directory not readable
  }

  return files;
}

/**
 * Detect source rule files
 */
function detectSourceFiles(cwd: string): DetectedFile[] {
  const files: DetectedFile[] = [];
  const rulesDir = join(cwd, ".aligntrue", "rules");

  if (existsSync(rulesDir)) {
    const ruleFiles = scanDirectory(rulesDir, ".md");
    for (const file of ruleFiles) {
      const relativePath = relative(cwd, file.path);
      files.push({
        path: relativePath.replace(/\\/g, "/"),
        type: "source",
        size: file.size,
      });
    }
  }

  return files;
}

/**
 * Detect configuration files
 */
function detectConfigFiles(cwd: string): DetectedFile[] {
  const files: DetectedFile[] = [];

  const configPath = join(cwd, ".aligntrue", "config.yaml");
  if (existsSync(configPath)) {
    const stat = statSync(configPath);
    files.push({
      path: ".aligntrue/config.yaml",
      type: "config",
      size: stat.size,
    });
  }

  return files;
}

/**
 * Detect lockfile (checks both new and old locations)
 */
function detectLockfile(cwd: string): DetectedFile | null {
  // Check new location first
  const newLockfilePath = join(cwd, ".aligntrue", "lock.json");
  if (existsSync(newLockfilePath)) {
    const stat = statSync(newLockfilePath);
    return {
      path: ".aligntrue/lock.json",
      type: "lockfile",
      size: stat.size,
    };
  }

  // Check legacy location
  const oldLockfilePath = join(cwd, ".aligntrue.lock.json");
  if (existsSync(oldLockfilePath)) {
    const stat = statSync(oldLockfilePath);
    return {
      path: ".aligntrue.lock.json",
      type: "lockfile",
      size: stat.size,
    };
  }
  return null;
}

/**
 * Detect cache directory
 */
function detectCacheDir(cwd: string): DetectedFile | null {
  const cacheDir = join(cwd, ".aligntrue", ".cache");
  if (existsSync(cacheDir)) {
    const stat = statSync(cacheDir);
    if (stat.isDirectory()) {
      const size = getDirectorySize(cacheDir);
      return {
        path: ".aligntrue/.cache",
        type: "cache",
        size,
      };
    }
  }
  return null;
}

/**
 * Detect backups directory
 */
function detectBackupsDir(cwd: string): DetectedFile | null {
  const backupsDir = join(cwd, ".aligntrue", ".backups");
  if (existsSync(backupsDir)) {
    const stat = statSync(backupsDir);
    if (stat.isDirectory()) {
      const size = getDirectorySize(backupsDir);
      return {
        path: ".aligntrue/.backups",
        type: "backup",
        size,
      };
    }
  }
  return null;
}

/**
 * Get total size of a directory
 */
function getDirectorySize(dir: string): number {
  let size = 0;
  try {
    const entries = readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      if (entry.isFile()) {
        size += statSync(fullPath).size;
      } else if (entry.isDirectory()) {
        size += getDirectorySize(fullPath);
      }
    }
  } catch {
    // Directory not readable
  }
  return size;
}

/**
 * Detect AlignTrue entries in .gitignore
 */
function detectGitignoreEntries(cwd: string): string[] {
  const gitignorePath = join(cwd, ".gitignore");
  if (!existsSync(gitignorePath)) {
    return [];
  }

  try {
    const content = readFileSync(gitignorePath, "utf-8");
    const entries: string[] = [];

    // Check for each marker type
    for (const marker of Object.values(GITIGNORE_MARKERS)) {
      // Safe: marker.start and marker.end are hardcoded constants, not user input
      // eslint-disable-next-line security/detect-non-literal-regexp
      const regex = new RegExp(
        `${escapeRegex(marker.start)}([\\s\\S]*?)${escapeRegex(marker.end)}`,
        "g",
      );
      const match = regex.exec(content);
      if (match && match[1]) {
        // Extract entries from the section
        const sectionEntries = match[1]
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line && !line.startsWith("#"));
        entries.push(...sectionEntries);
      }
    }

    return entries;
  } catch {
    return [];
  }
}

/**
 * Escape special regex characters
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
