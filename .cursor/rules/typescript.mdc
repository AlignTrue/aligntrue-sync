---
description: TypeScript development guide
globs:
  - "**/*.{ts,tsx}"
  - "tsconfig*.json"
  - ".eslintrc*"
  - "eslint.config.*"
  - "biome.*"
alwaysApply: false
---

# TypeScript development guide

TypeScript rules for correctness, determinism, and AI friendly maintenance. For tests, see `testing.mdc`. For determinism details, see `implementation_specs.mdc`.

---

## Core principles

1. Types first, then implementation.
2. No `any` creep.
3. Narrow at boundaries, stay precise inside.
4. Prefer simple data + pure functions over classes.
5. Fail fast with clear errors.

---

## tsconfig baseline (required)

Every project extends a strict shared config. Do not turn strictness off.

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "useUnknownInCatchVariables": true,
    "allowUnusedLabels": false,
    "importsNotUsedAsValues": "error",
    "resolveJsonModule": true,
    "skipLibCheck": true
  }
}
```

If a third party library is wrong, use `// @ts-expect-error <short reason>` on that line only.

---

## Linting and formatting

- Use `@typescript-eslint` with type aware config.
- Enforce:
  - `no-explicit-any`
  - `no-floating-promises`
  - `no-unsafe-argument`
  - `consistent-type-imports`
  - `no-unnecessary-type-assertion`
- Prefer Prettier as the single formatter.
- CI must run lint with type checking.

### Minimal eslint config

```json
{
  "extends": [
    "plugin:@typescript-eslint/recommended-type-checked",
    "plugin:@typescript-eslint/stylistic-type-checked"
  ],
  "parserOptions": { "project": true },
  "rules": {
    "@typescript-eslint/consistent-type-imports": [
      "error",
      { "prefer": "type-imports" }
    ],
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-floating-promises": "error",
    "@typescript-eslint/no-unsafe-argument": "error",
    "@typescript-eslint/no-unnecessary-type-assertion": "error",
    "@typescript-eslint/require-await": "error",
    "no-restricted-syntax": [
      "error",
      {
        "selector": "TSEnumDeclaration",
        "message": "Use unions of string literals instead of enums"
      }
    ]
  }
}
```

---

## Module and API boundaries

- Only named exports. No default exports.
- Barrel files only at package boundaries. Avoid deep barrels.
- Public APIs are small and explicit.
- Internals use relative imports within the package.
- Use `import type` for types.

```typescript
import type { User } from "./types";
```

---

## exactOptionalPropertyTypes pattern

Optional means "present with value" or "not present". Never assign `undefined` directly.

```typescript
interface Result {
  data: string;
  error?: string;
  metadata?: Record<string, unknown>;
}

// Good: omit when undefined
const error: string | undefined = getError();
const metadata: Record<string, unknown> | undefined = getMetadata();

const result: Result = {
  data: "success",
  ...(error !== undefined && { error }),
  ...(metadata !== undefined && { metadata }),
};
```

Pattern: `...(value !== undefined && { key: value })` for optional fields.

---

## noUncheckedIndexedAccess pattern

All indexed access is `T | undefined`. Narrow before use.

```typescript
const mapping: Record<string, string> = {
  "import-cursor": "cursor",
  "import-agents": "agents-md",
};

const agent = mapping[context];
if (!agent) {
  throw new Error(`Unknown context: ${context}`);
}
useAgent(agent);
```

Use `if (!value)`, `??`, or validation helpers instead of assuming presence.

---

## Boundary validation

At all external boundaries (CLI args, env, HTTP, files):

- Accept `unknown`.
- Validate with a schema library (Zod or equivalent).
- Throw small, actionable errors.

```typescript
import { z } from "zod";

const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  roles: z.array(z.enum(["admin", "member"])).default([]),
});

export type User = z.infer<typeof UserSchema>;

export function parseUser(input: unknown): User {
  const res = UserSchema.safeParse(input);
  if (!res.success) {
    const msg = res.error.issues
      .map((i) => `${i.path.join(".")}: ${i.message}`)
      .join("; ");
    throw new Error(`Invalid user: ${msg}`);
  }
  return res.data;
}
```

Never trust raw JSON, env, or config without validation.

---

## Prefer data + functions over classes

- Use plain objects and functions.
- Use discriminated unions for states.

```typescript
type Loading = { kind: "loading" };
type Success<T> = { kind: "success"; data: T };
type Failure = { kind: "failure"; error: string };
type RemoteData<T> = Loading | Success<T> | Failure;

export function fold<T, R>(
  rd: RemoteData<T>,
  fns: {
    loading: () => R;
    success: (t: T) => R;
    failure: (e: string) => R;
  },
): R {
  switch (rd.kind) {
    case "loading":
      return fns.loading();
    case "success":
      return fns.success(rd.data);
    case "failure":
      return fns.failure(rd.error);
    default:
      return assertNever(rd);
  }
}

function assertNever(x: never): never {
  throw new Error(`Unhandled case: ${JSON.stringify(x)}`);
}
```

---

## Exhaustiveness and narrowing

- Always exhaust unions.
- Use `assertNever` in default to force compiler checks.

```typescript
type Shape =
  | { tag: "circle"; radius: number }
  | { tag: "rect"; w: number; h: number };

export function area(s: Shape): number {
  switch (s.tag) {
    case "circle":
      return Math.PI * s.radius * s.radius;
    case "rect":
      return s.w * s.h;
    default:
      return assertNever(s);
  }
}
```

---

## Unknown over any

- Use `unknown`.
- Narrow with `typeof`, `in`, or schema parse before use.

```typescript
function parseJson(input: string): unknown {
  return JSON.parse(input);
}
```

---

## Prefer unions over enums

```typescript
export const Roles = ["admin", "member", "viewer"] as const;
export type Role = (typeof Roles)[number];
```

---

## Immutability defaults

- Prefer `Readonly` and `ReadonlyArray` at edges.
- Mutate only when needed and local.

```typescript
type Point = Readonly<{ x: number; y: number }>;
const points: ReadonlyArray<Point> = [{ x: 0, y: 0 }];
```

---

## File operations and safety

Avoid TOCTOU (time-of-check to time-of-use) race conditions. ESLint rule `no-check-then-operate` flags these patterns.

### Safe patterns

| Operation  | Pattern                                                                   | Reason                            |
| ---------- | ------------------------------------------------------------------------- | --------------------------------- |
| Read       | `readFileSync(path)`                                                      | Safe - no check needed            |
| Create dir | `ensureDirectoryExists(dir)`                                              | Atomic, handles concurrent access |
| Write      | `new AtomicFileWriter().write(path, content)`                             | Atomic, no intermediate state     |
| Delete     | `try { unlinkSync(path); } catch (e) { if (e.code !== "ENOENT") throw; }` | Handle file already gone          |

### Unsafe patterns (avoid)

```typescript
// ❌ TOCTOU: file could be deleted between check and write
if (!existsSync(file)) {
  writeFileSync(file, content);
}

// ❌ TOCTOU: directory could be created between check and mkdir
if (!existsSync(dir)) {
  mkdirSync(dir);
}

// ✅ Instead use:
import { ensureDirectoryExists, AtomicFileWriter } from "@aligntrue/file-utils";
ensureDirectoryExists(dir);
const writer = new AtomicFileWriter();
await writer.write(file, content);
```

Use `ensureDirectoryExists()` and `AtomicFileWriter` from `@aligntrue/file-utils` for all production code.

---

## Error handling

- Throw `Error`, not strings.
- For expected failures, use Result style types.

```typescript
type Ok<T> = { ok: true; value: T };
type Err<E = Error> = { ok: false; error: E };
export type Result<T, E = Error> = Ok<T> | Err<E>;

export function toErr(e: unknown): Error {
  return e instanceof Error ? e : new Error(String(e));
}
```

---

## Async discipline

- No unhandled promises.
- Use `no-floating-promises` in lint.
- Fire and forget only with explicit `void` and containment.

```typescript
void runBackground().catch((err) => {
  console.error("Background task failed", err);
});
```

---

## API and component typing

- All exported functions and components are typed.
- Use `satisfies` to keep config narrow.

```typescript
type Config = { region: "iad" | "dub"; retries: number };

export const config = {
  region: "iad",
  retries: 2,
} as const satisfies Config;
```

---

## Naming and structure

- Files: kebab case.
- React components: PascalCase.
- Functions and vars: camelCase.
- One module per concern.
- Tests mirror source tree.
- Prefer clear function/variable names over inline comments

```
src/
  core/
  features/
  components/
  types/
tests/
  core/
  features/
  components/
```

---

## Pitfalls to avoid

- Default exports.
- `as any` to silence errors.
- Optional booleans. Prefer unions like `type Flag = "on" | "off"`.
- `{}` or `object` as catch all types.
- Wildcard barrels that hide dependencies.
- Over generic abstractions without need.
- Types derived from runtime data without validation.
- Don't unnecessarily add try / catch
- Don't cast to 'any
- Avoid helper functions when a simple inline expression would suffice

---

## Pre commit checklist

```bash
tsc -p tsconfig.json --noEmit
pnpm exec eslint . --max-warnings=0
pnpm exec prettier -w .
```

For large refactors, run `pnpm exec knip` to find and remove unused exports, dependencies, and files.

---

## Related rules

- `testing.mdc`
- `security_linting_policy.mdc`
- `implementation_specs.mdc`
- `pull_request_standards.mdc`
