---
globs: scripts/**/*.js,scripts/**/*.mjs,packages/**/*.ts,packages/**/*.tsx,apps/**/*.ts,apps/**/*.tsx
alwaysApply: false
---

# Security Linting Policy

**Applies to**: `scripts/**/*.{js,mjs}`, `packages/**/*.{ts,tsx}`, `apps/**/*.{ts,tsx}`

## Overview

This document defines when to suppress vs fix security warnings from `eslint-plugin-security` to ensure `pnpm check` only shows actionable warnings. It covers both TypeScript source files and JavaScript tooling scripts like build tools, validation scripts, and CLI utilities.

## Core Principle

**Suppress false positives with documentation. Fix real vulnerabilities.**

## When to Suppress

### 1. Safe Internal Paths

**Suppress**: `security/detect-non-literal-fs-filename` for:

- Schema files resolved from `__dirname` at build time
- Paths from `getAlignTruePaths()` helper (all are safe internal paths)
- Lockfile, bundle, and IR file paths (`.aligntrue/rules`, `.aligntrue.lock.json`, etc.)
- Test fixtures and temporary files

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Internal schema file path, resolved from __dirname at build time (not user input)
const configSchema = JSON.parse(readFileSync(schemaPath, "utf8"));
```

**Rationale**: These paths are not user-controlled and are safe by construction.

### 2. Validated User Input

**Suppress**: `security/detect-non-literal-fs-filename` for paths that:

- Go through `validateScopePath()` at config load time
- Are validated for path traversal attacks
- Are checked for absolute paths

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Paths from config are validated via validateScopePath() at config load time (packages/core/src/config/index.ts:662)
content = readFileSync(sourcePath, "utf8");
```

**Rationale**: Validation prevents path traversal attacks, making the path safe.

### 3. Prototype Pollution Protection

**Suppress**: `security/detect-object-injection` for dynamic property access that:

- Has explicit `__proto__`, `constructor`, `prototype` checks before access
- Uses `Object.prototype.hasOwnProperty.call()` for property checks
- Validates keys before accessing object properties

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-object-injection
// Safe: Prototype pollution prevented by explicit __proto__/constructor/prototype checks above (lines 38-46)
current[segment] = {};
```

**Rationale**: Explicit checks prevent prototype pollution attacks.

### 4. Static Regex Patterns

**Suppress**: `security/detect-unsafe-regex` and `security/detect-non-literal-regexp` for:

- Static regex patterns (not constructed from user input)
- Patterns with bounded quantifiers (no nested quantifiers)
- Patterns used for parsing known-safe formats (markdown, JSON, etc.)

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-unsafe-regex
// Safe: Static regex pattern for parsing markdown links, bounded quantifiers prevent ReDoS
const LINK_PATTERN = /\[([^\]]+)\]\(\/docs\/([^)#]+)(?:#[^)]+)?\)/g;
```

**Rationale**: Static patterns are not vulnerable to ReDoS attacks.

### 5. Safe Child Process Execution

**Suppress**: `security/detect-child-process` for:

- `execSync()` with static, known commands (not user input)
- Pre-defined command allowlists
- Output that is parsed with static patterns only
- Build/validation scripts where commands are controlled

**Pattern** (JavaScript tooling scripts):

```javascript
// eslint-disable-next-line security/detect-child-process
// Safe: execSync runs static known command "pnpm lint", output parsed with static patterns
output = execSync("pnpm lint --max-warnings 0", { encoding: "utf-8" });
```

**Rationale**: Static commands with no user input are safe. Output parsing with static patterns prevents injection attacks.

**When to Fix**: If a script accepts user arguments to a command, validate and escape them before passing to `execSync()`.

## When to Fix

### 1. Unvalidated User Paths

**Fix**: All FS operations with user-provided paths must:

- Go through `validateScopePath()` or similar validation
- Check for path traversal (`..`)
- Reject absolute paths
- Normalize paths properly

**Example**:

```typescript
// ❌ Don't do this
readFileSync(userProvidedPath, "utf8");

// ✅ Do this
validateScopePath(userProvidedPath);
readFileSync(userProvidedPath, "utf8");
```

### 2. Unsafe Regex from User Input

**Fix**: All regex patterns constructed from user input must:

- Validate pattern length (max 200 characters)
- Escape special characters properly
- Check for nested quantifiers that could cause ReDoS
- Use `safeRegExp()` helper from `packages/core/src/security/regex-validator.ts`

**Example**:

```typescript
// ❌ Don't do this
const regex = new RegExp(`^${userPattern}$`);

// ✅ Do this
if (userPattern.length > 200) {
  throw new Error("Pattern too long");
}
const escaped = escapeForRegex(userPattern);
const regex = safeRegExp(`^${escaped}$`);
```

### 3. Unprotected Object Property Access

**Fix**: All dynamic property access with user input must:

- Check for `__proto__`, `constructor`, `prototype` before access
- Use `Object.prototype.hasOwnProperty.call()` for property checks
- Validate keys before accessing

**Example**:

```typescript
// ❌ Don't do this
obj[userKey] = value;

// ✅ Do this
if (
  userKey === "__proto__" ||
  userKey === "constructor" ||
  userKey === "prototype"
) {
  throw new Error("Invalid key");
}
obj[userKey] = value;
```

## Suppression Documentation Requirements

All suppressions must include:

1. **Rule name**: Which security rule is being suppressed
2. **Rationale**: Why the code is safe (internal path, validated input, protection in place)
3. **Reference**: Line numbers or function names where protection/validation occurs

**Good example**:

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Path is typically from getAlignTruePaths().lockfile (safe internal path)
const content = readFileSync(path, "utf8");
```

**Bad example** (missing rationale):

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
const content = readFileSync(path, "utf8");
```

## ESLint Overrides

For files where all operations are known-safe, use file-specific overrides in `eslint.config.js`:

```javascript
{
  files: ["packages/core/src/paths.ts"],
  rules: {
    // All paths from getAlignTruePaths() are safe internal paths (not user input)
    "security/detect-non-literal-fs-filename": "off",
  },
}
```

### JavaScript Tooling Scripts

For build and validation scripts in `scripts/`, override rules when appropriate:

```javascript
{
  files: ["scripts/**/*.mjs", "scripts/**/*.js"],
  rules: {
    // Scripts use static known commands via execSync, parsed with static patterns
    "security/detect-child-process": "off",
    // Scripts use safe internal paths from getAlignTruePaths() or __dirname
    "security/detect-non-literal-fs-filename": "off",
  },
}
```

**Use overrides for**:

- Utility files where all paths are safe
- Test files (if warnings are excessive)
- Tooling scripts where all commands and paths are static/hardcoded
- Files with many safe operations where inline suppressions would be noisy

**Do NOT use overrides for**:

- Scripts that accept command-line arguments
- Scripts that dynamically construct commands or paths
- Scripts that process user input

## Review Process

Before suppressing:

1. Verify the code is actually safe (not just convenient to suppress)
2. Check if validation/protection exists
3. Document the rationale clearly
4. Consider if a fix would be better (e.g., adding validation)
5. For tooling scripts: Ensure commands and paths are static/hardcoded, not derived from user input

## Examples

### Good Suppression

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Internal schema file path, resolved from __dirname at build time (not user input)
const configSchema = JSON.parse(readFileSync(schemaPath, "utf8"));
```

### Bad Suppression (missing validation)

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: User provided path (WRONG - needs validation!)
const content = readFileSync(userPath, "utf8");
```

### Good Fix

```typescript
// Validate user path first
validateScopePath(userPath);
const content = readFileSync(userPath, "utf8");
```

### Tooling Script Example (JavaScript)

**Good suppression**:

```javascript
// eslint-disable-next-line security/detect-child-process
// Safe: execSync runs static known command, output parsed with static patterns only
const output = execSync("pnpm lint --max-warnings 0", { encoding: "utf-8" });
const lines = output.split("\n");
```

**Bad suppression** (would need fixing):

```javascript
// eslint-disable-next-line security/detect-child-process
// Safe: executing user command (WRONG - needs validation!)
const output = execSync(userCommand, { encoding: "utf-8" });
```

**Correct approach**:

```javascript
// Validate command against allowlist
const ALLOWED_COMMANDS = ["lint", "test", "build"];
if (!ALLOWED_COMMANDS.includes(userCommand)) {
  throw new Error(`Command not allowed: ${userCommand}`);
}
const output = execSync(`pnpm ${userCommand}`, { encoding: "utf-8" });
```

## GitHub CodeQL Alerts

**Critical distinction**: CodeQL alerts are NOT suppressed with inline comments like ESLint. Use GitHub's security UI to dismiss false positives.

### Why lgtm comments don't work

The `lgtm[rule]` format was used by the deprecated LGTM.com service. Modern GitHub CodeQL does not reliably honor these inline suppressions. Remove any `// lgtm[...]` comments to avoid confusion.

### How to dismiss false positive CodeQL alerts

1. Go to https://github.com/AlignTrue/aligntrue/security/code-scanning
2. Click the alert
3. Select "Dismiss alert"
4. Choose category:
   - **False positive**: Alert is incorrect or code is genuinely safe
   - **Won't fix**: Alert is valid but intentionally not addressed
5. Add justification explaining:
   - Why the alert doesn't apply (validation, safe by construction, etc.)
   - Any safety measures in place

### Batch dismissal workflow

When dismissing multiple related alerts:

1. List alert numbers in ascending order (e.g., #366, #367, #368...) for easier tracking
2. GitHub UI shows alerts newest-first by default; sort by "Alert number" ascending if dismissing many
3. Use consistent justification text across related alerts for maintainability

**Template justification for test fixture temp files:**

> Test fixtures use isolated temp directories with crypto.randomBytes() for unpredictable paths and proper cleanup in afterEach(). Safe by construction per security_linting_policy.mdc.

### Documentation requirement

When dismissing CodeQL alerts, the justification must explain the safety measure:

**Good justification**:

> Temp file uses same-directory pattern with crypto randomness (not OS temp dir). Atomic rename on same filesystem prevents TOCTOU. See packages/file-utils/src/atomic-writer.ts.

**Poor justification**:

> False positive

### Examples of safe patterns that trigger alerts

| Alert                   | Safe Pattern                                         | Why                                                                        |
| ----------------------- | ---------------------------------------------------- | -------------------------------------------------------------------------- |
| insecure-temporary-file | Same-dir temp with crypto randomness + atomic rename | Atomic same-dir operations are always atomic across platforms              |
| http-to-file-access     | Fetch validated URL → write to internal cache path   | URL validated at construction; cache path is internal `.aligntrue/.cache/` |
| file-access-to-http     | Read file for HTTP headers (etag, etc.)              | Headers come from response object, not user input                          |

## Maintenance

- Review suppressions during code reviews
- Update suppressions if code changes
- Remove suppressions if validation is added
- Document new patterns as they arise
- Remove `// lgtm[...]` comments when found (they're ineffective with GitHub CodeQL)
